/*
 * generated by Xtext 2.25.0
 */
package robLANG_ASOS.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import robLANG_ASOS.And;
import robLANG_ASOS.ArrayAdd;
import robLANG_ASOS.ArrayGet;
import robLANG_ASOS.ArrayLength;
import robLANG_ASOS.ArrayNew;
import robLANG_ASOS.ArrayRemove;
import robLANG_ASOS.ArraySet;
import robLANG_ASOS.Assignment;
import robLANG_ASOS.Block;
import robLANG_ASOS.BoolConstant;
import robLANG_ASOS.BreakLoop;
import robLANG_ASOS.ComplexFunction;
import robLANG_ASOS.Condition;
import robLANG_ASOS.Divide;
import robLANG_ASOS.DoubleConstant;
import robLANG_ASOS.Equality;
import robLANG_ASOS.FunCall;
import robLANG_ASOS.FunParamCapture;
import robLANG_ASOS.FunParamExp;
import robLANG_ASOS.GetMaxSpeed;
import robLANG_ASOS.Greater;
import robLANG_ASOS.GreaterEq;
import robLANG_ASOS.Inequality;
import robLANG_ASOS.InlineFunction;
import robLANG_ASOS.IntConstant;
import robLANG_ASOS.Less;
import robLANG_ASOS.LessEq;
import robLANG_ASOS.Loop;
import robLANG_ASOS.MathAbs;
import robLANG_ASOS.MathCos;
import robLANG_ASOS.MathModulo;
import robLANG_ASOS.MathPow;
import robLANG_ASOS.MathSin;
import robLANG_ASOS.MathSqrt;
import robLANG_ASOS.Minus;
import robLANG_ASOS.MoveBackward;
import robLANG_ASOS.MoveForward;
import robLANG_ASOS.Multiply;
import robLANG_ASOS.Not;
import robLANG_ASOS.Or;
import robLANG_ASOS.Plus;
import robLANG_ASOS.PrintExpression;
import robLANG_ASOS.Return;
import robLANG_ASOS.RobLANG_ASOSPackage;
import robLANG_ASOS.Robot;
import robLANG_ASOS.SenseBattery;
import robLANG_ASOS.SenseCompass;
import robLANG_ASOS.SenseDistance;
import robLANG_ASOS.SensePosition;
import robLANG_ASOS.SenseTime;
import robLANG_ASOS.SetNominalSpeed;
import robLANG_ASOS.StringConstant;
import robLANG_ASOS.SymbolRef;
import robLANG_ASOS.TradeOff;
import robLANG_ASOS.TurnLeft;
import robLANG_ASOS.TurnRight;
import robLANG_ASOS.Type;
import robLANG_ASOS.Variable;
import robLANG_ASOS.services.RobLANGGrammarAccess;

@SuppressWarnings("all")
public class RobLANGSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RobLANGGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobLANG_ASOSPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobLANG_ASOSPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.ARRAY_ADD:
				sequence_ArrayAdd(context, (ArrayAdd) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.ARRAY_GET:
				sequence_ArrayGet(context, (ArrayGet) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.ARRAY_LENGTH:
				sequence_ArrayLength(context, (ArrayLength) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.ARRAY_NEW:
				sequence_ArrayNew(context, (ArrayNew) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.ARRAY_REMOVE:
				sequence_ArrayRemove(context, (ArrayRemove) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.ARRAY_SET:
				sequence_ArraySet(context, (ArraySet) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.BOOL_CONSTANT:
				sequence_Atomic(context, (BoolConstant) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.BREAK_LOOP:
				sequence_BreakLoop(context, (BreakLoop) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.COMPLEX_FUNCTION:
				if (rule == grammarAccess.getFunDefinitionRule()
						|| rule == grammarAccess.getComplexFunctionRule()) {
					sequence_ComplexFunction(context, (ComplexFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMainDefinitionRule()
						|| rule == grammarAccess.getComplexMainRule()) {
					sequence_ComplexMain(context, (ComplexFunction) semanticObject); 
					return; 
				}
				else break;
			case RobLANG_ASOSPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.DIVIDE:
				sequence_MulOrDiv(context, (Divide) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.DOUBLE_CONSTANT:
				sequence_Atomic(context, (DoubleConstant) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.FUN_CALL:
				sequence_FunCall(context, (FunCall) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.FUN_PARAM_CAPTURE:
				sequence_FunParam(context, (FunParamCapture) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.FUN_PARAM_EXP:
				sequence_FunParam(context, (FunParamExp) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.GET_MAX_SPEED:
				sequence_GetMaxSpeed(context, (GetMaxSpeed) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.GREATER:
				sequence_Comparison(context, (Greater) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.GREATER_EQ:
				sequence_Comparison(context, (GreaterEq) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.INEQUALITY:
				sequence_Equality(context, (Inequality) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.INLINE_FUNCTION:
				if (rule == grammarAccess.getFunDefinitionRule()
						|| rule == grammarAccess.getInlineFunctionRule()) {
					sequence_InlineFunction(context, (InlineFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMainDefinitionRule()
						|| rule == grammarAccess.getInlineMainRule()) {
					sequence_InlineMain(context, (InlineFunction) semanticObject); 
					return; 
				}
				else break;
			case RobLANG_ASOSPackage.INT_CONSTANT:
				sequence_Atomic(context, (IntConstant) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.LESS:
				sequence_Comparison(context, (Less) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.LESS_EQ:
				sequence_Comparison(context, (LessEq) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MATH_ABS:
				sequence_MathAbs(context, (MathAbs) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MATH_COS:
				sequence_MathCos(context, (MathCos) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MATH_MODULO:
				sequence_MathModulo(context, (MathModulo) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MATH_POW:
				sequence_MathPow(context, (MathPow) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MATH_SIN:
				sequence_MathSin(context, (MathSin) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MATH_SQRT:
				sequence_MathSqrt(context, (MathSqrt) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MOVE_BACKWARD:
				sequence_MoveBackward(context, (MoveBackward) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MOVE_FORWARD:
				sequence_MoveForward(context, (MoveForward) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.MULTIPLY:
				sequence_MulOrDiv(context, (Multiply) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.PARAMETER:
				sequence_Parameter(context, (robLANG_ASOS.Parameter) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.PRINT_EXPRESSION:
				sequence_PrintExpression(context, (PrintExpression) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.ROBOT:
				sequence_Robot(context, (Robot) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.SENSE_BATTERY:
				sequence_SenseBattery(context, (SenseBattery) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.SENSE_COMPASS:
				sequence_SenseCompass(context, (SenseCompass) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.SENSE_DISTANCE:
				sequence_SenseDistance(context, (SenseDistance) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.SENSE_POSITION:
				sequence_SensePosition(context, (SensePosition) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.SENSE_TIME:
				sequence_SenseTime(context, (SenseTime) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.SET_NOMINAL_SPEED:
				sequence_SetNominalSpeed(context, (SetNominalSpeed) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.STRING_CONSTANT:
				sequence_Atomic(context, (StringConstant) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.SYMBOL_REF:
				sequence_Atomic(context, (SymbolRef) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.TRADE_OFF:
				sequence_TradeOff(context, (TradeOff) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.TURN_LEFT:
				sequence_TurnLeft(context, (TurnLeft) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.TURN_RIGHT:
				sequence_TurnRight(context, (TurnRight) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case RobLANG_ASOSPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns And
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0_0_0 returns And
	 *     Equality.Inequality_1_0_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.GreaterEq_1_0_0_0 returns And
	 *     Comparison.LessEq_1_0_1_0 returns And
	 *     Comparison.Greater_1_0_2_0 returns And
	 *     Comparison.Less_1_0_3_0 returns And
	 *     PlusOrMinus returns And
	 *     PlusOrMinus.Plus_1_0_0_0 returns And
	 *     PlusOrMinus.Minus_1_0_1_0 returns And
	 *     MulOrDiv returns And
	 *     MulOrDiv.Multiply_1_0_0_0 returns And
	 *     MulOrDiv.Divide_1_0_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayAdd
	 *     ArrayStatement returns ArrayAdd
	 *     ArrayAdd returns ArrayAdd
	 *
	 * Constraint:
	 *     (array=Expression valueOrIndex=Expression indexedValue=Expression?)
	 */
	protected void sequence_ArrayAdd(ISerializationContext context, ArrayAdd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayGet
	 *     Expression returns ArrayGet
	 *     Or returns ArrayGet
	 *     Or.Or_1_0 returns ArrayGet
	 *     And returns ArrayGet
	 *     And.And_1_0 returns ArrayGet
	 *     Equality returns ArrayGet
	 *     Equality.Equality_1_0_0_0 returns ArrayGet
	 *     Equality.Inequality_1_0_1_0 returns ArrayGet
	 *     Comparison returns ArrayGet
	 *     Comparison.GreaterEq_1_0_0_0 returns ArrayGet
	 *     Comparison.LessEq_1_0_1_0 returns ArrayGet
	 *     Comparison.Greater_1_0_2_0 returns ArrayGet
	 *     Comparison.Less_1_0_3_0 returns ArrayGet
	 *     PlusOrMinus returns ArrayGet
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayGet
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayGet
	 *     MulOrDiv returns ArrayGet
	 *     MulOrDiv.Multiply_1_0_0_0 returns ArrayGet
	 *     MulOrDiv.Divide_1_0_1_0 returns ArrayGet
	 *     Primary returns ArrayGet
	 *     Atomic returns ArrayGet
	 *     ArrayExpression returns ArrayGet
	 *     ArrayGet returns ArrayGet
	 *
	 * Constraint:
	 *     (array=Expression index=Expression)
	 */
	protected void sequence_ArrayGet(ISerializationContext context, ArrayGet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_GET__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_GET__ARRAY));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_GET__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_GET__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayGetAccess().getArrayExpressionParserRuleCall_1_0(), semanticObject.getArray());
		feeder.accept(grammarAccess.getArrayGetAccess().getIndexExpressionParserRuleCall_3_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayLength
	 *     Expression returns ArrayLength
	 *     Or returns ArrayLength
	 *     Or.Or_1_0 returns ArrayLength
	 *     And returns ArrayLength
	 *     And.And_1_0 returns ArrayLength
	 *     Equality returns ArrayLength
	 *     Equality.Equality_1_0_0_0 returns ArrayLength
	 *     Equality.Inequality_1_0_1_0 returns ArrayLength
	 *     Comparison returns ArrayLength
	 *     Comparison.GreaterEq_1_0_0_0 returns ArrayLength
	 *     Comparison.LessEq_1_0_1_0 returns ArrayLength
	 *     Comparison.Greater_1_0_2_0 returns ArrayLength
	 *     Comparison.Less_1_0_3_0 returns ArrayLength
	 *     PlusOrMinus returns ArrayLength
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayLength
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayLength
	 *     MulOrDiv returns ArrayLength
	 *     MulOrDiv.Multiply_1_0_0_0 returns ArrayLength
	 *     MulOrDiv.Divide_1_0_1_0 returns ArrayLength
	 *     Primary returns ArrayLength
	 *     Atomic returns ArrayLength
	 *     ArrayExpression returns ArrayLength
	 *     ArrayLength returns ArrayLength
	 *
	 * Constraint:
	 *     array=Expression
	 */
	protected void sequence_ArrayLength(ISerializationContext context, ArrayLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_LENGTH__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_LENGTH__ARRAY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayLengthAccess().getArrayExpressionParserRuleCall_1_0(), semanticObject.getArray());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayNew
	 *     Expression returns ArrayNew
	 *     Or returns ArrayNew
	 *     Or.Or_1_0 returns ArrayNew
	 *     And returns ArrayNew
	 *     And.And_1_0 returns ArrayNew
	 *     Equality returns ArrayNew
	 *     Equality.Equality_1_0_0_0 returns ArrayNew
	 *     Equality.Inequality_1_0_1_0 returns ArrayNew
	 *     Comparison returns ArrayNew
	 *     Comparison.GreaterEq_1_0_0_0 returns ArrayNew
	 *     Comparison.LessEq_1_0_1_0 returns ArrayNew
	 *     Comparison.Greater_1_0_2_0 returns ArrayNew
	 *     Comparison.Less_1_0_3_0 returns ArrayNew
	 *     PlusOrMinus returns ArrayNew
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayNew
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayNew
	 *     MulOrDiv returns ArrayNew
	 *     MulOrDiv.Multiply_1_0_0_0 returns ArrayNew
	 *     MulOrDiv.Divide_1_0_1_0 returns ArrayNew
	 *     Primary returns ArrayNew
	 *     Atomic returns ArrayNew
	 *     ArrayExpression returns ArrayNew
	 *     ArrayNew returns ArrayNew
	 *
	 * Constraint:
	 *     dimension=INT
	 */
	protected void sequence_ArrayNew(ISerializationContext context, ArrayNew semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_NEW__DIMENSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_NEW__DIMENSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayNewAccess().getDimensionINTTerminalRuleCall_1_0(), semanticObject.getDimension());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayRemove
	 *     ArrayStatement returns ArrayRemove
	 *     ArrayRemove returns ArrayRemove
	 *
	 * Constraint:
	 *     (array=Expression index=Expression)
	 */
	protected void sequence_ArrayRemove(ISerializationContext context, ArrayRemove semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_STATEMENT__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_STATEMENT__ARRAY));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_REMOVE__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_REMOVE__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayRemoveAccess().getArrayExpressionParserRuleCall_1_0(), semanticObject.getArray());
		feeder.accept(grammarAccess.getArrayRemoveAccess().getIndexExpressionParserRuleCall_3_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArraySet
	 *     ArrayStatement returns ArraySet
	 *     ArraySet returns ArraySet
	 *
	 * Constraint:
	 *     (array=Expression index=Expression value=Expression)
	 */
	protected void sequence_ArraySet(ISerializationContext context, ArraySet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_STATEMENT__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_STATEMENT__ARRAY));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_SET__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_SET__INDEX));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_SET__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ARRAY_SET__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArraySetAccess().getArrayExpressionParserRuleCall_1_0(), semanticObject.getArray());
		feeder.accept(grammarAccess.getArraySetAccess().getIndexExpressionParserRuleCall_3_0(), semanticObject.getIndex());
		feeder.accept(grammarAccess.getArraySetAccess().getValueExpressionParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (assignee=[Symbol|ID] expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ASSIGNMENT__ASSIGNEE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ASSIGNMENT__ASSIGNEE));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getAssigneeSymbolIDTerminalRuleCall_0_0_1(), semanticObject.eGet(RobLANG_ASOSPackage.Literals.ASSIGNMENT__ASSIGNEE, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BoolConstant
	 *     Expression returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0_0_0 returns BoolConstant
	 *     Equality.Inequality_1_0_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.GreaterEq_1_0_0_0 returns BoolConstant
	 *     Comparison.LessEq_1_0_1_0 returns BoolConstant
	 *     Comparison.Greater_1_0_2_0 returns BoolConstant
	 *     Comparison.Less_1_0_3_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.Multiply_1_0_0_0 returns BoolConstant
	 *     MulOrDiv.Divide_1_0_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BOOL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BOOL_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueBOOLEANTerminalRuleCall_7_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DoubleConstant
	 *     Expression returns DoubleConstant
	 *     Or returns DoubleConstant
	 *     Or.Or_1_0 returns DoubleConstant
	 *     And returns DoubleConstant
	 *     And.And_1_0 returns DoubleConstant
	 *     Equality returns DoubleConstant
	 *     Equality.Equality_1_0_0_0 returns DoubleConstant
	 *     Equality.Inequality_1_0_1_0 returns DoubleConstant
	 *     Comparison returns DoubleConstant
	 *     Comparison.GreaterEq_1_0_0_0 returns DoubleConstant
	 *     Comparison.LessEq_1_0_1_0 returns DoubleConstant
	 *     Comparison.Greater_1_0_2_0 returns DoubleConstant
	 *     Comparison.Less_1_0_3_0 returns DoubleConstant
	 *     PlusOrMinus returns DoubleConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns DoubleConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns DoubleConstant
	 *     MulOrDiv returns DoubleConstant
	 *     MulOrDiv.Multiply_1_0_0_0 returns DoubleConstant
	 *     MulOrDiv.Divide_1_0_1_0 returns DoubleConstant
	 *     Primary returns DoubleConstant
	 *     Atomic returns DoubleConstant
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_Atomic(ISerializationContext context, DoubleConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.DOUBLE_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.DOUBLE_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueDOUBLETerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntConstant
	 *     Expression returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0_0_0 returns IntConstant
	 *     Equality.Inequality_1_0_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.GreaterEq_1_0_0_0 returns IntConstant
	 *     Comparison.LessEq_1_0_1_0 returns IntConstant
	 *     Comparison.Greater_1_0_2_0 returns IntConstant
	 *     Comparison.Less_1_0_3_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.Multiply_1_0_0_0 returns IntConstant
	 *     MulOrDiv.Divide_1_0_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StringConstant
	 *     Expression returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     Equality returns StringConstant
	 *     Equality.Equality_1_0_0_0 returns StringConstant
	 *     Equality.Inequality_1_0_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.GreaterEq_1_0_0_0 returns StringConstant
	 *     Comparison.LessEq_1_0_1_0 returns StringConstant
	 *     Comparison.Greater_1_0_2_0 returns StringConstant
	 *     Comparison.Less_1_0_3_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.Multiply_1_0_0_0 returns StringConstant
	 *     MulOrDiv.Divide_1_0_1_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     Atomic returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SymbolRef
	 *     Expression returns SymbolRef
	 *     Or returns SymbolRef
	 *     Or.Or_1_0 returns SymbolRef
	 *     And returns SymbolRef
	 *     And.And_1_0 returns SymbolRef
	 *     Equality returns SymbolRef
	 *     Equality.Equality_1_0_0_0 returns SymbolRef
	 *     Equality.Inequality_1_0_1_0 returns SymbolRef
	 *     Comparison returns SymbolRef
	 *     Comparison.GreaterEq_1_0_0_0 returns SymbolRef
	 *     Comparison.LessEq_1_0_1_0 returns SymbolRef
	 *     Comparison.Greater_1_0_2_0 returns SymbolRef
	 *     Comparison.Less_1_0_3_0 returns SymbolRef
	 *     PlusOrMinus returns SymbolRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns SymbolRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns SymbolRef
	 *     MulOrDiv returns SymbolRef
	 *     MulOrDiv.Multiply_1_0_0_0 returns SymbolRef
	 *     MulOrDiv.Divide_1_0_1_0 returns SymbolRef
	 *     Primary returns SymbolRef
	 *     Atomic returns SymbolRef
	 *
	 * Constraint:
	 *     variable=[Symbol|ID]
	 */
	protected void sequence_Atomic(ISerializationContext context, SymbolRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getVariableSymbolIDTerminalRuleCall_8_1_0_1(), semanticObject.eGet(RobLANG_ASOSPackage.Literals.SYMBOL_REF__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BreakLoop
	 *     BreakLoop returns BreakLoop
	 *
	 * Constraint:
	 *     {BreakLoop}
	 */
	protected void sequence_BreakLoop(ISerializationContext context, BreakLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Greater
	 *     Expression returns Greater
	 *     Or returns Greater
	 *     Or.Or_1_0 returns Greater
	 *     And returns Greater
	 *     And.And_1_0 returns Greater
	 *     Equality returns Greater
	 *     Equality.Equality_1_0_0_0 returns Greater
	 *     Equality.Inequality_1_0_1_0 returns Greater
	 *     Comparison returns Greater
	 *     Comparison.GreaterEq_1_0_0_0 returns Greater
	 *     Comparison.LessEq_1_0_1_0 returns Greater
	 *     Comparison.Greater_1_0_2_0 returns Greater
	 *     Comparison.Less_1_0_3_0 returns Greater
	 *     PlusOrMinus returns Greater
	 *     PlusOrMinus.Plus_1_0_0_0 returns Greater
	 *     PlusOrMinus.Minus_1_0_1_0 returns Greater
	 *     MulOrDiv returns Greater
	 *     MulOrDiv.Multiply_1_0_0_0 returns Greater
	 *     MulOrDiv.Divide_1_0_1_0 returns Greater
	 *     Primary returns Greater
	 *
	 * Constraint:
	 *     (left=Comparison_Greater_1_0_2_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGreaterLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GreaterEq
	 *     Expression returns GreaterEq
	 *     Or returns GreaterEq
	 *     Or.Or_1_0 returns GreaterEq
	 *     And returns GreaterEq
	 *     And.And_1_0 returns GreaterEq
	 *     Equality returns GreaterEq
	 *     Equality.Equality_1_0_0_0 returns GreaterEq
	 *     Equality.Inequality_1_0_1_0 returns GreaterEq
	 *     Comparison returns GreaterEq
	 *     Comparison.GreaterEq_1_0_0_0 returns GreaterEq
	 *     Comparison.LessEq_1_0_1_0 returns GreaterEq
	 *     Comparison.Greater_1_0_2_0 returns GreaterEq
	 *     Comparison.Less_1_0_3_0 returns GreaterEq
	 *     PlusOrMinus returns GreaterEq
	 *     PlusOrMinus.Plus_1_0_0_0 returns GreaterEq
	 *     PlusOrMinus.Minus_1_0_1_0 returns GreaterEq
	 *     MulOrDiv returns GreaterEq
	 *     MulOrDiv.Multiply_1_0_0_0 returns GreaterEq
	 *     MulOrDiv.Divide_1_0_1_0 returns GreaterEq
	 *     Primary returns GreaterEq
	 *
	 * Constraint:
	 *     (left=Comparison_GreaterEq_1_0_0_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, GreaterEq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGreaterEqLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Less
	 *     Expression returns Less
	 *     Or returns Less
	 *     Or.Or_1_0 returns Less
	 *     And returns Less
	 *     And.And_1_0 returns Less
	 *     Equality returns Less
	 *     Equality.Equality_1_0_0_0 returns Less
	 *     Equality.Inequality_1_0_1_0 returns Less
	 *     Comparison returns Less
	 *     Comparison.GreaterEq_1_0_0_0 returns Less
	 *     Comparison.LessEq_1_0_1_0 returns Less
	 *     Comparison.Greater_1_0_2_0 returns Less
	 *     Comparison.Less_1_0_3_0 returns Less
	 *     PlusOrMinus returns Less
	 *     PlusOrMinus.Plus_1_0_0_0 returns Less
	 *     PlusOrMinus.Minus_1_0_1_0 returns Less
	 *     MulOrDiv returns Less
	 *     MulOrDiv.Multiply_1_0_0_0 returns Less
	 *     MulOrDiv.Divide_1_0_1_0 returns Less
	 *     Primary returns Less
	 *
	 * Constraint:
	 *     (left=Comparison_Less_1_0_3_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Less semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLessLeftAction_1_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LessEq
	 *     Expression returns LessEq
	 *     Or returns LessEq
	 *     Or.Or_1_0 returns LessEq
	 *     And returns LessEq
	 *     And.And_1_0 returns LessEq
	 *     Equality returns LessEq
	 *     Equality.Equality_1_0_0_0 returns LessEq
	 *     Equality.Inequality_1_0_1_0 returns LessEq
	 *     Comparison returns LessEq
	 *     Comparison.GreaterEq_1_0_0_0 returns LessEq
	 *     Comparison.LessEq_1_0_1_0 returns LessEq
	 *     Comparison.Greater_1_0_2_0 returns LessEq
	 *     Comparison.Less_1_0_3_0 returns LessEq
	 *     PlusOrMinus returns LessEq
	 *     PlusOrMinus.Plus_1_0_0_0 returns LessEq
	 *     PlusOrMinus.Minus_1_0_1_0 returns LessEq
	 *     MulOrDiv returns LessEq
	 *     MulOrDiv.Multiply_1_0_0_0 returns LessEq
	 *     MulOrDiv.Divide_1_0_1_0 returns LessEq
	 *     Primary returns LessEq
	 *
	 * Constraint:
	 *     (left=Comparison_LessEq_1_0_1_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, LessEq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLessEqLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunDefinition returns ComplexFunction
	 *     ComplexFunction returns ComplexFunction
	 *
	 * Constraint:
	 *     (type=Type name=ID (varNames+=Parameter varNames+=Parameter*)? body=Block)
	 */
	protected void sequence_ComplexFunction(ISerializationContext context, ComplexFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MainDefinition returns ComplexFunction
	 *     ComplexMain returns ComplexFunction
	 *
	 * Constraint:
	 *     (type=Type name='Main' (varNames+=Parameter varNames+=Parameter*)? body=Block)
	 */
	protected void sequence_ComplexMain(ISerializationContext context, ComplexFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (expression=Expression ifz=Block elsez=Block?)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Equality
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0_0_0 returns Equality
	 *     Equality.Inequality_1_0_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.GreaterEq_1_0_0_0 returns Equality
	 *     Comparison.LessEq_1_0_1_0 returns Equality
	 *     Comparison.Greater_1_0_2_0 returns Equality
	 *     Comparison.Less_1_0_3_0 returns Equality
	 *     PlusOrMinus returns Equality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Equality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Equality
	 *     MulOrDiv returns Equality
	 *     MulOrDiv.Multiply_1_0_0_0 returns Equality
	 *     MulOrDiv.Divide_1_0_1_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0_0_0 right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getRightComparisonParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Inequality
	 *     Expression returns Inequality
	 *     Or returns Inequality
	 *     Or.Or_1_0 returns Inequality
	 *     And returns Inequality
	 *     And.And_1_0 returns Inequality
	 *     Equality returns Inequality
	 *     Equality.Equality_1_0_0_0 returns Inequality
	 *     Equality.Inequality_1_0_1_0 returns Inequality
	 *     Comparison returns Inequality
	 *     Comparison.GreaterEq_1_0_0_0 returns Inequality
	 *     Comparison.LessEq_1_0_1_0 returns Inequality
	 *     Comparison.Greater_1_0_2_0 returns Inequality
	 *     Comparison.Less_1_0_3_0 returns Inequality
	 *     PlusOrMinus returns Inequality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Inequality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Inequality
	 *     MulOrDiv returns Inequality
	 *     MulOrDiv.Multiply_1_0_0_0 returns Inequality
	 *     MulOrDiv.Divide_1_0_1_0 returns Inequality
	 *     Primary returns Inequality
	 *
	 * Constraint:
	 *     (left=Equality_Inequality_1_0_1_0 right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Inequality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getInequalityLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getRightComparisonParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunCall returns FunCall
	 *     Statement returns FunCall
	 *     Expression returns FunCall
	 *     Or returns FunCall
	 *     Or.Or_1_0 returns FunCall
	 *     And returns FunCall
	 *     And.And_1_0 returns FunCall
	 *     Equality returns FunCall
	 *     Equality.Equality_1_0_0_0 returns FunCall
	 *     Equality.Inequality_1_0_1_0 returns FunCall
	 *     Comparison returns FunCall
	 *     Comparison.GreaterEq_1_0_0_0 returns FunCall
	 *     Comparison.LessEq_1_0_1_0 returns FunCall
	 *     Comparison.Greater_1_0_2_0 returns FunCall
	 *     Comparison.Less_1_0_3_0 returns FunCall
	 *     PlusOrMinus returns FunCall
	 *     PlusOrMinus.Plus_1_0_0_0 returns FunCall
	 *     PlusOrMinus.Minus_1_0_1_0 returns FunCall
	 *     MulOrDiv returns FunCall
	 *     MulOrDiv.Multiply_1_0_0_0 returns FunCall
	 *     MulOrDiv.Divide_1_0_1_0 returns FunCall
	 *     Primary returns FunCall
	 *     Atomic returns FunCall
	 *
	 * Constraint:
	 *     (function=[FunDefinition|ID] (params+=FunParam params+=FunParam*)?)
	 */
	protected void sequence_FunCall(ISerializationContext context, FunCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunParam returns FunParamCapture
	 *
	 * Constraint:
	 *     variable=[Variable|ID]
	 */
	protected void sequence_FunParam(ISerializationContext context, FunParamCapture semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.FUN_PARAM_CAPTURE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.FUN_PARAM_CAPTURE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunParamAccess().getVariableVariableIDTerminalRuleCall_1_2_0_1(), semanticObject.eGet(RobLANG_ASOSPackage.Literals.FUN_PARAM_CAPTURE__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunParam returns FunParamExp
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_FunParam(ISerializationContext context, FunParamExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.FUN_PARAM_EXP__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.FUN_PARAM_EXP__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunParamAccess().getExprExpressionParserRuleCall_0_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GetMaxSpeed
	 *     Effector returns GetMaxSpeed
	 *     Speed returns GetMaxSpeed
	 *     GetMaxSpeed returns GetMaxSpeed
	 *
	 * Constraint:
	 *     {GetMaxSpeed}
	 */
	protected void sequence_GetMaxSpeed(ISerializationContext context, GetMaxSpeed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunDefinition returns InlineFunction
	 *     InlineFunction returns InlineFunction
	 *
	 * Constraint:
	 *     (type=Type name=ID (varNames+=Parameter varNames+=Parameter*)? expression=Expression)
	 */
	protected void sequence_InlineFunction(ISerializationContext context, InlineFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MainDefinition returns InlineFunction
	 *     InlineMain returns InlineFunction
	 *
	 * Constraint:
	 *     (type=Type name='Main' (varNames+=Parameter varNames+=Parameter*)? expression=Expression)
	 */
	protected void sequence_InlineMain(ISerializationContext context, InlineFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (expression=Expression body=Block)
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.LOOP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.LOOP__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.LOOP__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.LOOP__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getLoopAccess().getBodyBlockParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathAbs
	 *     Expression returns MathAbs
	 *     Or returns MathAbs
	 *     Or.Or_1_0 returns MathAbs
	 *     And returns MathAbs
	 *     And.And_1_0 returns MathAbs
	 *     Equality returns MathAbs
	 *     Equality.Equality_1_0_0_0 returns MathAbs
	 *     Equality.Inequality_1_0_1_0 returns MathAbs
	 *     Comparison returns MathAbs
	 *     Comparison.GreaterEq_1_0_0_0 returns MathAbs
	 *     Comparison.LessEq_1_0_1_0 returns MathAbs
	 *     Comparison.Greater_1_0_2_0 returns MathAbs
	 *     Comparison.Less_1_0_3_0 returns MathAbs
	 *     PlusOrMinus returns MathAbs
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathAbs
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathAbs
	 *     MulOrDiv returns MathAbs
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathAbs
	 *     MulOrDiv.Divide_1_0_1_0 returns MathAbs
	 *     Primary returns MathAbs
	 *     Atomic returns MathAbs
	 *     MathExpression returns MathAbs
	 *     MathAbs returns MathAbs
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_MathAbs(ISerializationContext context, MathAbs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MATH_ABS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MATH_ABS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathAbsAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathCos
	 *     Expression returns MathCos
	 *     Or returns MathCos
	 *     Or.Or_1_0 returns MathCos
	 *     And returns MathCos
	 *     And.And_1_0 returns MathCos
	 *     Equality returns MathCos
	 *     Equality.Equality_1_0_0_0 returns MathCos
	 *     Equality.Inequality_1_0_1_0 returns MathCos
	 *     Comparison returns MathCos
	 *     Comparison.GreaterEq_1_0_0_0 returns MathCos
	 *     Comparison.LessEq_1_0_1_0 returns MathCos
	 *     Comparison.Greater_1_0_2_0 returns MathCos
	 *     Comparison.Less_1_0_3_0 returns MathCos
	 *     PlusOrMinus returns MathCos
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathCos
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathCos
	 *     MulOrDiv returns MathCos
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathCos
	 *     MulOrDiv.Divide_1_0_1_0 returns MathCos
	 *     Primary returns MathCos
	 *     Atomic returns MathCos
	 *     MathExpression returns MathCos
	 *     MathCos returns MathCos
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_MathCos(ISerializationContext context, MathCos semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MATH_COS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MATH_COS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathCosAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathModulo
	 *     Expression returns MathModulo
	 *     Or returns MathModulo
	 *     Or.Or_1_0 returns MathModulo
	 *     And returns MathModulo
	 *     And.And_1_0 returns MathModulo
	 *     Equality returns MathModulo
	 *     Equality.Equality_1_0_0_0 returns MathModulo
	 *     Equality.Inequality_1_0_1_0 returns MathModulo
	 *     Comparison returns MathModulo
	 *     Comparison.GreaterEq_1_0_0_0 returns MathModulo
	 *     Comparison.LessEq_1_0_1_0 returns MathModulo
	 *     Comparison.Greater_1_0_2_0 returns MathModulo
	 *     Comparison.Less_1_0_3_0 returns MathModulo
	 *     PlusOrMinus returns MathModulo
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathModulo
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathModulo
	 *     MulOrDiv returns MathModulo
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathModulo
	 *     MulOrDiv.Divide_1_0_1_0 returns MathModulo
	 *     Primary returns MathModulo
	 *     Atomic returns MathModulo
	 *     MathExpression returns MathModulo
	 *     MathModulo returns MathModulo
	 *
	 * Constraint:
	 *     (lhs=Expression rhs=Expression)
	 */
	protected void sequence_MathModulo(ISerializationContext context, MathModulo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MATH_MODULO__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MATH_MODULO__LHS));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MATH_MODULO__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MATH_MODULO__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathModuloAccess().getLhsExpressionParserRuleCall_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getMathModuloAccess().getRhsExpressionParserRuleCall_3_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathPow
	 *     Expression returns MathPow
	 *     Or returns MathPow
	 *     Or.Or_1_0 returns MathPow
	 *     And returns MathPow
	 *     And.And_1_0 returns MathPow
	 *     Equality returns MathPow
	 *     Equality.Equality_1_0_0_0 returns MathPow
	 *     Equality.Inequality_1_0_1_0 returns MathPow
	 *     Comparison returns MathPow
	 *     Comparison.GreaterEq_1_0_0_0 returns MathPow
	 *     Comparison.LessEq_1_0_1_0 returns MathPow
	 *     Comparison.Greater_1_0_2_0 returns MathPow
	 *     Comparison.Less_1_0_3_0 returns MathPow
	 *     PlusOrMinus returns MathPow
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathPow
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathPow
	 *     MulOrDiv returns MathPow
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathPow
	 *     MulOrDiv.Divide_1_0_1_0 returns MathPow
	 *     Primary returns MathPow
	 *     Atomic returns MathPow
	 *     MathExpression returns MathPow
	 *     MathPow returns MathPow
	 *
	 * Constraint:
	 *     (value=Expression exponant=Expression)
	 */
	protected void sequence_MathPow(ISerializationContext context, MathPow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MATH_POW__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MATH_POW__VALUE));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MATH_POW__EXPONANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MATH_POW__EXPONANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathPowAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getMathPowAccess().getExponantExpressionParserRuleCall_3_0(), semanticObject.getExponant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathSin
	 *     Expression returns MathSin
	 *     Or returns MathSin
	 *     Or.Or_1_0 returns MathSin
	 *     And returns MathSin
	 *     And.And_1_0 returns MathSin
	 *     Equality returns MathSin
	 *     Equality.Equality_1_0_0_0 returns MathSin
	 *     Equality.Inequality_1_0_1_0 returns MathSin
	 *     Comparison returns MathSin
	 *     Comparison.GreaterEq_1_0_0_0 returns MathSin
	 *     Comparison.LessEq_1_0_1_0 returns MathSin
	 *     Comparison.Greater_1_0_2_0 returns MathSin
	 *     Comparison.Less_1_0_3_0 returns MathSin
	 *     PlusOrMinus returns MathSin
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathSin
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathSin
	 *     MulOrDiv returns MathSin
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathSin
	 *     MulOrDiv.Divide_1_0_1_0 returns MathSin
	 *     Primary returns MathSin
	 *     Atomic returns MathSin
	 *     MathExpression returns MathSin
	 *     MathSin returns MathSin
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_MathSin(ISerializationContext context, MathSin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MATH_SIN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MATH_SIN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathSinAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathSqrt
	 *     Expression returns MathSqrt
	 *     Or returns MathSqrt
	 *     Or.Or_1_0 returns MathSqrt
	 *     And returns MathSqrt
	 *     And.And_1_0 returns MathSqrt
	 *     Equality returns MathSqrt
	 *     Equality.Equality_1_0_0_0 returns MathSqrt
	 *     Equality.Inequality_1_0_1_0 returns MathSqrt
	 *     Comparison returns MathSqrt
	 *     Comparison.GreaterEq_1_0_0_0 returns MathSqrt
	 *     Comparison.LessEq_1_0_1_0 returns MathSqrt
	 *     Comparison.Greater_1_0_2_0 returns MathSqrt
	 *     Comparison.Less_1_0_3_0 returns MathSqrt
	 *     PlusOrMinus returns MathSqrt
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathSqrt
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathSqrt
	 *     MulOrDiv returns MathSqrt
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathSqrt
	 *     MulOrDiv.Divide_1_0_1_0 returns MathSqrt
	 *     Primary returns MathSqrt
	 *     Atomic returns MathSqrt
	 *     MathExpression returns MathSqrt
	 *     MathSqrt returns MathSqrt
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_MathSqrt(ISerializationContext context, MathSqrt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MATH_SQRT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MATH_SQRT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathSqrtAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MoveBackward
	 *     Effector returns MoveBackward
	 *     Move returns MoveBackward
	 *     MoveBackward returns MoveBackward
	 *
	 * Constraint:
	 *     distance=Expression
	 */
	protected void sequence_MoveBackward(ISerializationContext context, MoveBackward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MOVE__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MOVE__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveBackwardAccess().getDistanceExpressionParserRuleCall_1_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MoveForward
	 *     Effector returns MoveForward
	 *     Move returns MoveForward
	 *     MoveForward returns MoveForward
	 *
	 * Constraint:
	 *     distance=Expression
	 */
	protected void sequence_MoveForward(ISerializationContext context, MoveForward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.MOVE__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.MOVE__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveForwardAccess().getDistanceExpressionParserRuleCall_1_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Divide
	 *     Expression returns Divide
	 *     Or returns Divide
	 *     Or.Or_1_0 returns Divide
	 *     And returns Divide
	 *     And.And_1_0 returns Divide
	 *     Equality returns Divide
	 *     Equality.Equality_1_0_0_0 returns Divide
	 *     Equality.Inequality_1_0_1_0 returns Divide
	 *     Comparison returns Divide
	 *     Comparison.GreaterEq_1_0_0_0 returns Divide
	 *     Comparison.LessEq_1_0_1_0 returns Divide
	 *     Comparison.Greater_1_0_2_0 returns Divide
	 *     Comparison.Less_1_0_3_0 returns Divide
	 *     PlusOrMinus returns Divide
	 *     PlusOrMinus.Plus_1_0_0_0 returns Divide
	 *     PlusOrMinus.Minus_1_0_1_0 returns Divide
	 *     MulOrDiv returns Divide
	 *     MulOrDiv.Multiply_1_0_0_0 returns Divide
	 *     MulOrDiv.Divide_1_0_1_0 returns Divide
	 *     Primary returns Divide
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Divide_1_0_1_0 right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getDivideLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Multiply
	 *     Expression returns Multiply
	 *     Or returns Multiply
	 *     Or.Or_1_0 returns Multiply
	 *     And returns Multiply
	 *     And.And_1_0 returns Multiply
	 *     Equality returns Multiply
	 *     Equality.Equality_1_0_0_0 returns Multiply
	 *     Equality.Inequality_1_0_1_0 returns Multiply
	 *     Comparison returns Multiply
	 *     Comparison.GreaterEq_1_0_0_0 returns Multiply
	 *     Comparison.LessEq_1_0_1_0 returns Multiply
	 *     Comparison.Greater_1_0_2_0 returns Multiply
	 *     Comparison.Less_1_0_3_0 returns Multiply
	 *     PlusOrMinus returns Multiply
	 *     PlusOrMinus.Plus_1_0_0_0 returns Multiply
	 *     PlusOrMinus.Minus_1_0_1_0 returns Multiply
	 *     MulOrDiv returns Multiply
	 *     MulOrDiv.Multiply_1_0_0_0 returns Multiply
	 *     MulOrDiv.Divide_1_0_1_0 returns Multiply
	 *     Primary returns Multiply
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Multiply_1_0_0_0 right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Multiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getMultiplyLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Or
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0_0_0 returns Or
	 *     Equality.Inequality_1_0_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.GreaterEq_1_0_0_0 returns Or
	 *     Comparison.LessEq_1_0_1_0 returns Or
	 *     Comparison.Greater_1_0_2_0 returns Or
	 *     Comparison.Less_1_0_3_0 returns Or
	 *     PlusOrMinus returns Or
	 *     PlusOrMinus.Plus_1_0_0_0 returns Or
	 *     PlusOrMinus.Minus_1_0_1_0 returns Or
	 *     MulOrDiv returns Or
	 *     MulOrDiv.Multiply_1_0_0_0 returns Or
	 *     MulOrDiv.Divide_1_0_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (type=Type name=ID)
	 */
	protected void sequence_Parameter(ISerializationContext context, robLANG_ASOS.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL__TYPE));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Minus
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0_0_0 returns Minus
	 *     Equality.Inequality_1_0_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.GreaterEq_1_0_0_0 returns Minus
	 *     Comparison.LessEq_1_0_1_0 returns Minus
	 *     Comparison.Greater_1_0_2_0 returns Minus
	 *     Comparison.Less_1_0_3_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *     MulOrDiv returns Minus
	 *     MulOrDiv.Multiply_1_0_0_0 returns Minus
	 *     MulOrDiv.Divide_1_0_1_0 returns Minus
	 *     Primary returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Plus
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0_0_0 returns Plus
	 *     Equality.Inequality_1_0_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.GreaterEq_1_0_0_0 returns Plus
	 *     Comparison.LessEq_1_0_1_0 returns Plus
	 *     Comparison.Greater_1_0_2_0 returns Plus
	 *     Comparison.Less_1_0_3_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *     MulOrDiv returns Plus
	 *     MulOrDiv.Multiply_1_0_0_0 returns Plus
	 *     MulOrDiv.Divide_1_0_1_0 returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Not
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0_0_0 returns Not
	 *     Equality.Inequality_1_0_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.GreaterEq_1_0_0_0 returns Not
	 *     Comparison.LessEq_1_0_1_0 returns Not
	 *     Comparison.Greater_1_0_2_0 returns Not
	 *     Comparison.Less_1_0_3_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.Multiply_1_0_0_0 returns Not
	 *     MulOrDiv.Divide_1_0_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintExpression
	 *     PrintExpression returns PrintExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_PrintExpression(ISerializationContext context, PrintExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.PRINT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.PRINT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintExpressionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.RETURN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.RETURN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Robot returns Robot
	 *
	 * Constraint:
	 *     (name=ID functions+=FunDefinition* main=MainDefinition functions+=FunDefinition*)
	 */
	protected void sequence_Robot(ISerializationContext context, Robot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SenseBattery
	 *     Expression returns SenseBattery
	 *     Or returns SenseBattery
	 *     Or.Or_1_0 returns SenseBattery
	 *     And returns SenseBattery
	 *     And.And_1_0 returns SenseBattery
	 *     Equality returns SenseBattery
	 *     Equality.Equality_1_0_0_0 returns SenseBattery
	 *     Equality.Inequality_1_0_1_0 returns SenseBattery
	 *     Comparison returns SenseBattery
	 *     Comparison.GreaterEq_1_0_0_0 returns SenseBattery
	 *     Comparison.LessEq_1_0_1_0 returns SenseBattery
	 *     Comparison.Greater_1_0_2_0 returns SenseBattery
	 *     Comparison.Less_1_0_3_0 returns SenseBattery
	 *     PlusOrMinus returns SenseBattery
	 *     PlusOrMinus.Plus_1_0_0_0 returns SenseBattery
	 *     PlusOrMinus.Minus_1_0_1_0 returns SenseBattery
	 *     MulOrDiv returns SenseBattery
	 *     MulOrDiv.Multiply_1_0_0_0 returns SenseBattery
	 *     MulOrDiv.Divide_1_0_1_0 returns SenseBattery
	 *     Primary returns SenseBattery
	 *     Atomic returns SenseBattery
	 *     Sensor returns SenseBattery
	 *     SenseBattery returns SenseBattery
	 *
	 * Constraint:
	 *     {SenseBattery}
	 */
	protected void sequence_SenseBattery(ISerializationContext context, SenseBattery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SenseCompass
	 *     Expression returns SenseCompass
	 *     Or returns SenseCompass
	 *     Or.Or_1_0 returns SenseCompass
	 *     And returns SenseCompass
	 *     And.And_1_0 returns SenseCompass
	 *     Equality returns SenseCompass
	 *     Equality.Equality_1_0_0_0 returns SenseCompass
	 *     Equality.Inequality_1_0_1_0 returns SenseCompass
	 *     Comparison returns SenseCompass
	 *     Comparison.GreaterEq_1_0_0_0 returns SenseCompass
	 *     Comparison.LessEq_1_0_1_0 returns SenseCompass
	 *     Comparison.Greater_1_0_2_0 returns SenseCompass
	 *     Comparison.Less_1_0_3_0 returns SenseCompass
	 *     PlusOrMinus returns SenseCompass
	 *     PlusOrMinus.Plus_1_0_0_0 returns SenseCompass
	 *     PlusOrMinus.Minus_1_0_1_0 returns SenseCompass
	 *     MulOrDiv returns SenseCompass
	 *     MulOrDiv.Multiply_1_0_0_0 returns SenseCompass
	 *     MulOrDiv.Divide_1_0_1_0 returns SenseCompass
	 *     Primary returns SenseCompass
	 *     Atomic returns SenseCompass
	 *     Sensor returns SenseCompass
	 *     SenseCompass returns SenseCompass
	 *
	 * Constraint:
	 *     {SenseCompass}
	 */
	protected void sequence_SenseCompass(ISerializationContext context, SenseCompass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SenseDistance
	 *     Expression returns SenseDistance
	 *     Or returns SenseDistance
	 *     Or.Or_1_0 returns SenseDistance
	 *     And returns SenseDistance
	 *     And.And_1_0 returns SenseDistance
	 *     Equality returns SenseDistance
	 *     Equality.Equality_1_0_0_0 returns SenseDistance
	 *     Equality.Inequality_1_0_1_0 returns SenseDistance
	 *     Comparison returns SenseDistance
	 *     Comparison.GreaterEq_1_0_0_0 returns SenseDistance
	 *     Comparison.LessEq_1_0_1_0 returns SenseDistance
	 *     Comparison.Greater_1_0_2_0 returns SenseDistance
	 *     Comparison.Less_1_0_3_0 returns SenseDistance
	 *     PlusOrMinus returns SenseDistance
	 *     PlusOrMinus.Plus_1_0_0_0 returns SenseDistance
	 *     PlusOrMinus.Minus_1_0_1_0 returns SenseDistance
	 *     MulOrDiv returns SenseDistance
	 *     MulOrDiv.Multiply_1_0_0_0 returns SenseDistance
	 *     MulOrDiv.Divide_1_0_1_0 returns SenseDistance
	 *     Primary returns SenseDistance
	 *     Atomic returns SenseDistance
	 *     Sensor returns SenseDistance
	 *     SenseDistance returns SenseDistance
	 *
	 * Constraint:
	 *     sensorIndex=INT
	 */
	protected void sequence_SenseDistance(ISerializationContext context, SenseDistance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.SENSE_DISTANCE__SENSOR_INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.SENSE_DISTANCE__SENSOR_INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSenseDistanceAccess().getSensorIndexINTTerminalRuleCall_3_0(), semanticObject.getSensorIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SensePosition
	 *     Expression returns SensePosition
	 *     Or returns SensePosition
	 *     Or.Or_1_0 returns SensePosition
	 *     And returns SensePosition
	 *     And.And_1_0 returns SensePosition
	 *     Equality returns SensePosition
	 *     Equality.Equality_1_0_0_0 returns SensePosition
	 *     Equality.Inequality_1_0_1_0 returns SensePosition
	 *     Comparison returns SensePosition
	 *     Comparison.GreaterEq_1_0_0_0 returns SensePosition
	 *     Comparison.LessEq_1_0_1_0 returns SensePosition
	 *     Comparison.Greater_1_0_2_0 returns SensePosition
	 *     Comparison.Less_1_0_3_0 returns SensePosition
	 *     PlusOrMinus returns SensePosition
	 *     PlusOrMinus.Plus_1_0_0_0 returns SensePosition
	 *     PlusOrMinus.Minus_1_0_1_0 returns SensePosition
	 *     MulOrDiv returns SensePosition
	 *     MulOrDiv.Multiply_1_0_0_0 returns SensePosition
	 *     MulOrDiv.Divide_1_0_1_0 returns SensePosition
	 *     Primary returns SensePosition
	 *     Atomic returns SensePosition
	 *     Sensor returns SensePosition
	 *     SensePosition returns SensePosition
	 *
	 * Constraint:
	 *     {SensePosition}
	 */
	protected void sequence_SensePosition(ISerializationContext context, SensePosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SenseTime
	 *     Expression returns SenseTime
	 *     Or returns SenseTime
	 *     Or.Or_1_0 returns SenseTime
	 *     And returns SenseTime
	 *     And.And_1_0 returns SenseTime
	 *     Equality returns SenseTime
	 *     Equality.Equality_1_0_0_0 returns SenseTime
	 *     Equality.Inequality_1_0_1_0 returns SenseTime
	 *     Comparison returns SenseTime
	 *     Comparison.GreaterEq_1_0_0_0 returns SenseTime
	 *     Comparison.LessEq_1_0_1_0 returns SenseTime
	 *     Comparison.Greater_1_0_2_0 returns SenseTime
	 *     Comparison.Less_1_0_3_0 returns SenseTime
	 *     PlusOrMinus returns SenseTime
	 *     PlusOrMinus.Plus_1_0_0_0 returns SenseTime
	 *     PlusOrMinus.Minus_1_0_1_0 returns SenseTime
	 *     MulOrDiv returns SenseTime
	 *     MulOrDiv.Multiply_1_0_0_0 returns SenseTime
	 *     MulOrDiv.Divide_1_0_1_0 returns SenseTime
	 *     Primary returns SenseTime
	 *     Atomic returns SenseTime
	 *     Sensor returns SenseTime
	 *     SenseTime returns SenseTime
	 *
	 * Constraint:
	 *     {SenseTime}
	 */
	protected void sequence_SenseTime(ISerializationContext context, SenseTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetNominalSpeed
	 *     Effector returns SetNominalSpeed
	 *     Speed returns SetNominalSpeed
	 *     SetNominalSpeed returns SetNominalSpeed
	 *
	 * Constraint:
	 *     speed=Expression
	 */
	protected void sequence_SetNominalSpeed(ISerializationContext context, SetNominalSpeed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.SET_NOMINAL_SPEED__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.SET_NOMINAL_SPEED__SPEED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetNominalSpeedAccess().getSpeedExpressionParserRuleCall_2_0(), semanticObject.getSpeed());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TradeOff
	 *     TradeOff returns TradeOff
	 *
	 * Constraint:
	 *     (properties+=STRING values+=Expression (properties+=STRING values+=Expression)+)
	 */
	protected void sequence_TradeOff(ISerializationContext context, TradeOff semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TurnLeft
	 *     Effector returns TurnLeft
	 *     Turn returns TurnLeft
	 *     TurnLeft returns TurnLeft
	 *
	 * Constraint:
	 *     angle=Expression
	 */
	protected void sequence_TurnLeft(ISerializationContext context, TurnLeft semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.TURN__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.TURN__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTurnLeftAccess().getAngleExpressionParserRuleCall_1_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TurnRight
	 *     Effector returns TurnRight
	 *     Turn returns TurnRight
	 *     TurnRight returns TurnRight
	 *
	 * Constraint:
	 *     angle=Expression
	 */
	protected void sequence_TurnRight(ISerializationContext context, TurnRight semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.TURN__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.TURN__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTurnRightAccess().getAngleExpressionParserRuleCall_1_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (type=BasicType dimension=INT?)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns Variable
	 *     Statement returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (type=Type name=ID expression=Expression)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL__TYPE));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.SYMBOL__NAME));
			if (transientValues.isValueTransient(semanticObject, RobLANG_ASOSPackage.Literals.VARIABLE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANG_ASOSPackage.Literals.VARIABLE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
}
